<?php
// $Id$

/**
 * @file openruth.module
 * Drupal implementation of ZRuth's openruth SOAP API
 */

/**
 * Implementation of hook_menu().
 */
function openruth_menu() {
  $items = array();

  $items['admin/settings/openruth'] = array(
    'title' => 'OpenRuth',
    'description' => 'Settings for OpenRuth module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('openruth_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'openruth.admin.inc',
  );

  $items['admin/settings/openruth/main'] = array(
    'title' => 'OpenRuth',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  return $items;
}

/**
 * Return an OpenruthClient instance.
 */
function openruth_client() {
  // This is basically a singleton. We also wait until right before
  // instantiating to include our required classes. That seems like a
  // decent performance tradeoff instead of loading everything on every
  // page load.
  static $client;
  if (!isset($client)) {
    $path = drupal_get_path('module', 'openruth');
    include($path . '/lib/OpenruthClient/OpenruthClient.class.php');
    $client = new OpenruthClient(
      variable_get('openruth_wsdl_url', ''),
      variable_get('openruth_agency_id', '')
    );
  }
  return $client;

}

// USER FUNCTIONS


/**
 * Implementation of hook_user().
 */
function openruth_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'login':
      if ($account->openruth_creds) {
        $_SESSION['openruth_creds'][$account->uid] = $account->openruth_creds;
        unset($account->openruth_creds);
      }
      break;
  }
}

/**
 * Implementation of hook_cron().
 *
 * Delete credentials after a while.
 */
function openruth_cron() {
  // TODO: Move variable from ding_library_user
  $expire_time = $_SERVER['REQUEST_TIME'] - variable_get('ding_library_user_credential_cache_duration', 1800);
  $res = db_query("SELECT sid, session, timestamp FROM {session} WHERE timestamp < %d", $expire_time);
  // As the only PHP functions that reads and writes the
  // almost-but-not-quite-serialized-data format of sessions does it to/from
  // the current session, we're using our own session as a scratchpad.
  $old_session = $_SESSION;
  while ($row = db_fetch_object($res)) {
    $_SESSION = array();
    session_decode($ros->session);
    if (isset($_SESSION['openruth_creds'])) {
      unset($_SESSION['openruth_creds']);
      $new_session = session_encode();
      db_query("UPDATE {session} SET session = '%s' WHERE sid = %d AND timestamp = %d", $new_session, $row->sid, $row->timestamp);
    }
  }
  $_SESSION = $old_session;
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function openruth_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ding_provider') {
    return "plugins/$plugin";
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * Alter the login form to disable the standard Drupal username/password
 * combination and provide our own fields instead.
 */
function openruth_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    case 'user_login':
    case 'user_login_block':
      // Since the login name can be a user's CPR-number, that too is hidden.
      $form['name']['#type'] = 'password';
      // Add our own validation handler, before the default Drupal login
      // validator.
      array_splice($form['#validate'], array_search('user_login_authenticate_validate', $form['#validate']), 0, 'openruth_user_login_validate');
      break;
  }
}

/**
 * Validation for the login form.
 */
function openruth_user_login_validate($form, &$form_state) {
  openruth_authenticate($form_state['values']);
}

/**
 */
function openruth_authenticate(&$form_values) {
  $res = openruth_client()->user_check($form_values['name'], $form_values['pass']);

  if (is_string($res)) {
    watchdog('openruth', 'Error in user_check: @error', array('@error' => $res), WATCHDOG_ERROR);
    return;
  }
  elseif (!$res->userFound || !$res->userPinCodeOk) {
    // Not found.
    return;
  }

  if ($res->userBlocked) {
    // Tell the user...
  }

  $auth_name = md5(drupal_get_private_key() . $form_values['name']) . '@openruth';
  user_external_login_register($auth_name, 'openruth_user');

  global $user;
  // Save credentials for later use.
  $user->openruth_creds = array(
    'user_id' => $form_values['name'],
    'password' => $form_values['pass'],
  );

  $user_status = _openruth_user_status($user, $form_values['name'], $form_values['pass']);

  if ($user_status && isset($user_status->userInfo)) {
    $user_info = $user_status->userInfo;
    // Set display_name
    $user->display_name = $user_info->userFirstName . ' ' . $user_info->userLastName;
  }
  elseif ($res->userEmail) {
    $user->display_name = $res->userEmail;
  }
  else {
    // What can we do? Use auth_name.
    $user->display_name = $auth_name;
  }

  // Finalize login.
  user_authenticate_finalize($form_values);
}

/**
 * Get OpenRuth credentials for user.
 */
function _openruth_get_credentials($account) {
  // See if we have credentials for the given user in the session.
  if ($_SESSION['openruth_creds'][$account->uid]) {
    return $_SESSION['openruth_creds'][$account->uid];
  }
  return DING_PROVIDER_AUTH_REQUIRED;
}

/**
 * Get user status.
 *
 * Session cached for efficiency.
 */
function _openruth_user_status($account = NULL, $name = NULL, $pass = NULL) {
  // Flush cache if account is not specified.
  if (!is_array($_SESSION['openruth_user_status']) || !$account) {
    $_SESSION['openruth_user_status'] = array();
  }
  if (!$account) {
    return;
  }

  if (!$name) {
    $creds = _openruth_get_credentials($account);
    if ($creds == DING_PROVIDER_AUTH_REQUIRED) {
      return;
    }
    $name = $creds['user_id'];
    $pass = $creds['password'];
  }
  $id = md5($name . $pass);

  if (!isset($_SESSION['openruth_user_status'][$id]) ||
    $_SESSION['openruth_user_status'][$id]['time'] < ($_SERVER['REQUEST_TIME'] - 300)) {
    $status = openruth_client()->user_status($name, $pass);
    if ($status && !is_string($status)) {
      $_SESSION['openruth_user_status'][$id] = array(
        'time' => $_SERVER['REQUEST_TIME'],
        'data' => $status,
      );
    }
    elseif (is_string($status)) {
      watchdog('openruth', 'Error fetching user status @error', array('@error' => $status), WATCHDOG_ERROR);
      return;
    }
  }
  if ($_SESSION['openruth_user_status'][$id]) {
    return $_SESSION['openruth_user_status'][$id]['data'];
  }
}

/**
 * Map openruth error messages to user visible error messages.
 *
 * @param mixed $error
 *   An specific error message, if empty, return array of all messages.
 * @return mixed
 *   String or array, depending on arguments.
 */
function openruth_renew_error($error = NULL) {
  static $errors;
  if (!$errors) {
    $errors = array(
      "rejected" => t('Renewal rejected.'),
      "reserved" => t('Cannot renew, material reserved,'),
      "booked" => t('Cannot renew, material reserved'),
      "copy reserved" => t('Cannot renew, material reserved'),
      "user is blocked" => t('Renewal rejected.'),
      "copy not on loan by user" => t('Renewal rejected.'),
      "copy not on loan" => t('Renewal rejected.'),
      "copy does not exist" => t('Renewal rejected.'),
      "ILL, not renewable" => t("Renewal not possible"),
    );
  }

  if ($error) {
    if (isset($errors[$error])) {
      return $errors[$error];
    }
    return $errors['rejected'];
  }
  return $errors;
}