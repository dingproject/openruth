<?php
// $Id$

/**
 * @file openruth.module
 * Drupal implementation of ZRuth's openruth SOAP API
 */

/**
 * Return an OpenruthClient instance.
 */
function openruth_client() {
  // This is basically a singleton. We also wait until right before
  // instantiating to include our required classes. That seems like a
  // decent performance tradeoff instead of loading everything on every
  // page load.
  static $client;
  if (!isset($client)) {
    $path = drupal_get_path('module', 'openruth');
    include($path . '/lib/OpenruthClient/OpenruthClient.class.php');
    $client = new OpenruthClient(
      variable_get('openruth_wsdl_url', ''),
      variable_get('openruth_agency_id', '')
    );
  }
  return $client;

}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function openruth_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ding_provider') {
    return "plugins/$plugin";
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * Alter the login form to disable the standard Drupal username/password
 * combination and provide our own fields instead.
 */
function openruth_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    case 'user_login':
    case 'user_login_block':
    case 'ding_library_user_forms_authenticate':
      // Since the login name can be a user's CPR-number, that too is hidden.
      $form['name']['#type'] = 'password';
       break;
  }
}

/**
 * Get user status.
 *
 * Session cached for efficiency.
 */
function _openruth_user_status($creds = NULL, $reset = FALSE) {
  $user = NULL;
  // Flush cache if creds is not specified.
  if ($reset || !is_array($_SESSION['openruth_user_status']) || !$creds) {
    $_SESSION['openruth_user_status'] = array();
  }
  if (!$creds) {
    return;
  }
  if (is_object($creds)) {
    $user = $creds;
    $creds = ding_library_user_get_credentials($user);
    if ($creds == DING_PROVIDER_AUTH_REQUIRED) {
      return $creds;
    }
  }
  $id = md5($creds['name'] . $creds['pass']);

  if (!isset($_SESSION['openruth_user_status'][$id]) ||
    $_SESSION['openruth_user_status'][$id]['time'] < ($_SERVER['REQUEST_TIME'] - 300)) {
    $status = openruth_client()->user_status($creds['name'], $creds['pass']);
    if ($status && !is_string($status)) {
      $_SESSION['openruth_user_status'][$id] = array(
        'time' => $_SERVER['REQUEST_TIME'],
        'data' => $status,
      );
      if ($user) {
        // If we have a user object, copy properties.
        if (isset($status->userInfo)) {
          $user_info = $status->userInfo;
          // Set display_name
          $extra['display_name'] = $user_info->userFirstName . ' ' . $user_info->userLastName;
          if ($user_info->agencyCounter) {
            $extra['preferred_branch'] = $user_info->agencyCounter;
          }
          if ($user_info->userEmail) {
            $extra['mail'] = $user_info->userEmail;
          }
        }
        else {
          // What can we do? Use auth_name.
          $extra['display_name'] = $user->name;
        }

        // Save properties to local user object, if they've changed.
        foreach ($extra as $key => $value) {
          if ($account->$key != $value) {
            user_save($user, $extra);
            break;
          }
        }
      }
    }
    elseif (is_string($status)) {
      watchdog('openruth', 'Error fetching user status @error', array('@error' => $status), WATCHDOG_ERROR);
      return;
    }
  }
  if ($_SESSION['openruth_user_status'][$id]) {
    return $_SESSION['openruth_user_status'][$id]['data'];
  }
}

/**
 * Get agency counters.
 *
 * Logs errors.
 *
 * @todo
 * Should probably cache the list.
 */
function _openruth_get_agency_counters() {
  static $branches;
  if (!isset($branches)) {
    $branches = openruth_client()->get_agency_counters();
    if (is_string($branches)) {
      watchdog('openruth', 'Error fetching agency counters: @error', array('@error' => $branches), WATCHDOG_ERROR);
      $branches = array();
    }
    elseif (!is_array($branches)) {
      watchdog('openruth', 'Unknown error fetching agency counters.', NULL, WATCHDOG_ERROR);
      $branches = array();
    }
  }
  return $branches;
}

/**
 * Element validator.
 */
function openruth_element_validate_number($element, &$form_state) {
  if (!preg_match('/^\d+/', $element['#value']) || !($element['#value'] > 0)) {
    form_error($element, t('Valid positive number required.'));
  }
}

/**
 * Element validator.
 */
function openruth_element_validate_future_date(&$element, &$form_state) {
  if (!empty($element['#value']['date'])) {
    list($year, $month, $day) = explode('-', trim($element['#value']['date']));
    if (!checkdate($month, $day, $year)) {
      form_error($element, t('Invalid date'));
    }

    $timestamp = strtotime($element['#value']['date']);
    if ($timestamp <= $_SERVER['REQUEST_TIME']) {
      form_error($element, t('Date must be later than today.'));
    }
  }
}

/**
 * Element validator.
 */
function openruth_element_validate_options($element, &$form_state, $complete) {
  // Don't bother if we already got errors.
  if (!form_get_errors() && !empty($element['start_date']['#value']['date']) && !empty($element['start_date']['#value']['date'])) {
    if (strtotime($element['start_date']['#value']['date']) > strtotime($element['end_date']['#value']['date'])) {
      form_error($element['end_date'], t('End date must be later than start date.'));
    }
  }
}

/**
 * Map openruth renewal error messages to user visible error messages.
 *
 * @param mixed $error
 *   An specific error message, if empty, return array of all messages.
 * @return mixed
 *   String or array, depending on arguments.
 */
function openruth_renew_error($error = NULL) {
  static $errors;
  if (!$errors) {
    $errors = array(
      "rejected" => t('Renewal rejected.'),
      "reserved" => t('Cannot renew, material reserved.'),
      "booked" => t('Cannot renew, material reserved.'),
      "copy reserved" => t('Cannot renew, material reserved.'),
      "user is blocked" => t('Renewal rejected.'),
      "copy not on loan by user" => t('Renewal rejected.'),
      "copy not on loan" => t('Renewal rejected.'),
      "copy does not exist" => t('Renewal rejected.'),
      "ILL, not renewable" => t("Renewal not possible."),
      // Special case
      'not implemented yet' => t("Not implemented."),
    );
  }

  if ($error) {
    if (isset($errors[$error])) {
      return $errors[$error];
    }
    watchdog('openruth', 'Unknown error while renewing: @error', array('@error' => $error), WATCHDOG_ERROR);
    return $errors['rejected'];
  }
  return $errors;
}

// Reservation related functions.

/**
 * Map openruth reservation error messages to user visible error messages.
 *
 * @param mixed $error
 *   An specific error message, if empty, return array of all messages.
 * @return mixed
 *   String or array, depending on arguments.
 */
function openruth_reservation_error($error = NULL) {
  static $errors;
  if (!$errors) {
    $errors = array(
      "ordering not allowed for this user" => t('Reservation not possible.'),
      "already on loan by user" => t('Already on loan by user.'),
      "already reserved by user" => t('Already reserved by user.'),
      "no copies available for reservation" => t('No copies available for reservation.'),
      "loan not allowed for this user category" => t('Reservation not possible.'),
      "loan not allowed, user too young" => t('Reservation not possible.'),
      "unspecified error, order not possible" =>t('Error reserving.'),
      "system error" =>t('Error reserving.'),
      "unknown agencyId" =>t('Error reserving.'),
    );
  }

  if ($error) {
    if (isset($errors[$error])) {
      return $errors[$error];
    }
    watchdog('openruth', 'Unknown error while reserving: @error', array('@error' => $error), WATCHDOG_ERROR);
    return $errors['system error'];
  }
  return $errors;
}

/**
 *
 */
function openruth_reservation_error_code($error) {
  static $errors;
  if (!$errors) {
    $errors = array(
      "ordering not allowed for this user" => DING_RESERVATION_ERROR_NOT_ALLOWED,
      "already on loan by user" => DING_RESERVATION_ERROR_NOT_AVAILABLE,
      "already reserved by user" => DING_RESERVATION_ERROR_RESERVATION_EXISTS,
      "no copies available for reservation" => DING_RESERVATION_ERROR_NOT_AVAILABLE,
      "loan not allowed for this user category" => DING_RESERVATION_ERROR_NOT_ALLOWED,
      "loan not allowed, user too young" => DING_RESERVATION_ERROR_NOT_ALLOWED,
      "unspecified error, order not possible" => DING_RESERVATION_ERROR,
      "system error" => DING_RESERVATION_ERROR,
      "unknown agencyId" => DING_RESERVATION_ERROR,
      TRUE => DING_RESERVATION_SUCCESS,
    );
  }

  if (isset($errors[$error])) {
    return $errors[$error];
  }
  watchdog('openruth', 'Unknown error while reserving: @error', array('@error' => $error), WATCHDOG_ERROR);
  return $errors['system error'];
}

function openruth_form_openruth_user_library_settings_form_alter(&$form, $form_state) {
  $account = $form['account']['#value'];

  $form['options']['interest_period'] = array(
    '#type' => 'select',
    '#title' => t('Period of interest'),
    '#description' => t('How long are you willing to wait for a reservation?'),
    '#options' => array(
      '30' => t('A month'),
      '60' => t('Two months'),
      '90' => t('Three months'),
      '183' => t('Six months'),
      '365' => t('A year'),
    ),
    '#default_value' => (isset($account->interest_period) && $account->interest_period > 10) ? $account->interest_period : DING_RESERVATION_DEFAULT_INTEREST_PERIOD,
  );

  $form['options']['pickup_branch'] = array(
    '#type' => 'select',
    '#title' => t('Preferred library'),
    '#options' => _openruth_get_agency_counters(),
    '#default_value' => $account->preferred_branch,
  );

  $form['buttons']['update'] = array(
    '#type' => 'submit',
    '#value' => t('Update'),
    '#attributes' => array('class' => 'update-button'),
    '#submit' => array('openruth_openruth_user_library_settings_form_submit'),
  );
}

/**
 * Submit handler for user library settings.
 */
function openruth_openruth_user_library_settings_form_submit($form, &$form_state) {
  $account = $form_state['values']['account'];
  $creds = ding_library_user_get_credentials($account);

  $updates = array();
  if ($form_state['values']['pickup_branch'] != $account->preferred_branch) {
    $updates['preferred_branch'] = $form_state['values']['pickup_branch'];
  }

  if ($form_state['values']['interest_period'] != $account->interest_period) {
    $updates['interest_period'] = $form_state['values']['interest_branch'];
  }
  if (!empty($updates)) {
    // user_save($account, $updates);
    if (isset($updates['preferred_branch'])) {
      // Update Integra
      openruth_client()->update_userinfo($creds['name'], $creds['pass'], $updates);
      // Force an immediate refresh.
      _openruth_user_status($account, TRUE);
    }
  }
}

function openruth_form_ding_reservation_list_form_alter(&$form, $form_state) {
  $form['options']['new_expiry'] = array(
    '#type' => 'date_popup',
    '#title' => t('Valid to'),
    '#date_format' => DATE_FORMAT_DATE,
    '#date_year_range' => '-0:+2',
  );

  $branches = array(
    '' => t("No change"),
  );
  $branches += _openruth_get_agency_counters();

  $form['options']['new_pickup_branch'] = array(
    '#type' => 'select',
    '#title' => t('New pickup branch'),
    '#options' => $branches,
  );

  $form['buttons']['update'] = array(
    '#type' => 'submit',
    '#value' => t('Save changes for selected reservations'),
    '#attributes' => array('class' => 'update-button'),
    '#validate' => array('openruth_ding_reservation_list_form_validate'),
    '#submit' => array('openruth_ding_reservation_list_form_update'),
  );

  $form['buttons']['remove'] = array(
    '#type' => 'submit',
    '#value' => t('Delete selected reservations'),
    '#attributes' => array('class' => 'cancel-button'),
    '#submit' => array('openruth_ding_reservation_list_form_remove'),
  );
}

function openruth_ding_reservation_list_form_validate($form, &$form_state) {
  $reservations = $form_state['values']['reservations'];

  if ((!empty($form_state['values']['new_expiry']) ||
      !empty($form_state['values']['new_pickup_branch'])) &&
    empty($form_state['values']['selected'])) {
    form_error($form['selected'], t('You must select some reservations.'));
  }

  foreach (array_filter($form_state['values']['selected']) as $id) {
    // Detect fetchable reservations...
    if (($reservations[$id]['status'] == 'fetchable')) {
      if (!empty($form_state['values']['new_expiry'])) {
        form_error($form['selected'][$id], t('You can not change expiry on reservations which are ready for pick up'));
      }
      if ($form_state['values']['new_pickup_branch'] != $reservations[$id]['pickup_branch']) {
        form_error($form['selected'][$id], t('You can not change pickup branch on reservations which are ready for pick up'));
      }
    }
  }

  if (!empty($form_state['values']['new_expiry'])) {
    list($year, $month, $day) = explode('-', trim($form_state['values']['new_expiry']));
    if (!checkdate($month, $day, $year)) {
      form_error($form['options']['new_expiry'], t('Invalid date'));
    }

    $timestamp = strtotime($form_state['values']['new_expiry']);

    if ($timestamp <= $_SERVER['REQUEST_TIME']) {
      form_error($form['options']['new_expiry'], t('Date must be later than today.'));
    }
    else {
      form_set_value($form['options']['new_expiry'], format_date($timestamp, 'custom', 'Y-m-d'), $form_state);
    }
  }
}

/**
 * Submit function.
 *
 * Updates selected reservations.
 */
function openruth_ding_reservation_list_form_update($form, &$form_state) {
  // TODO: Not implemented in the service yet.
  $creds = ding_library_user_get_credentials($form_state['values']['account']);
  if ($creds == DING_PROVIDER_AUTH_REQUIRED) {
    drupal_set_message('You must be logged in to delete reservations');
    return;
  }
  $reservations_ids = array_filter($form_state['values']['selected']);
  $res = array();
  foreach ($reservations_ids as $reservations_id) {
    $expiry = empty($form_state['values']['new_expiry']) ?
      $form_state['values']['reservations'][$reservations_id]['valid_to'] :
      $form_state['values']['new_expiry'];
    $pickup_branch = empty($form_state['values']['new_pickup_branch']) ?
      $form_state['values']['reservations'][$reservations_id]['pickup_branch'] :
      $form_state['values']['new_pickup_branch'];
    $res[] = openruth_client()->update_order($reservations_id, $pickup_branch, $expiry);
  }

  $successes = in_array(TRUE, $res);
  $failures = in_array(FALSE, $res);
  if ($successes && !$failures){
    drupal_set_message(t('Reservations updated.'));
  }
  elseif ($failures && !$successes) {
    drupal_set_message(t('Could not update reservations.', 'error'));
  }
  else {
    drupal_set_message(t('Updated @ok_count reservations, @failed_count failed', array('@ok_count' => $counts[TRUE], '@failed_count' => $counts[FALSE])), 'error');
  }

  // Flush cached user status.
  _openruth_user_status();
}

/**
 * Submit function.
 *
 * Updates selected reservations.
 */
function openruth_ding_reservation_list_form_remove($form, $form_state) {
  // TODO: Not implemented in the service yet.
  $creds = ding_library_user_get_credentials($form_state['values']['account']);
  if ($creds == DING_PROVIDER_AUTH_REQUIRED) {
    drupal_set_message('You must be logged in to delete reservations');
    return;
  }
  $reservations_ids = array_filter($form_state['values']['selected']);

  $successes = $failures = array();
  foreach ($reservations_ids as $reservations_id) {
    if (openruth_client()->cancel_order($reservations_id)) {
      $successes[] = $reservations_id;
    }
    else {
      $failures[] = $reservations_id;
    }
  }

  if (!empty($successes) && empty($failures)){
    drupal_set_message(t('Reservations deleted.'));
  }
  elseif (!empty($failures) && empty($successes)) {
    drupal_set_message(t('Could not delete reservations.', 'error'));
  }
  else {
    drupal_set_message(t('Deleted @ok_count reservations, @failed_count failed', array('@ok_count' => sizeof($successes), '@failed_count' => sizeof($failures))), 'error');
  }
  // Flush cached user status.
  _openruth_user_status();
}

// Cart reservation support.

/**
 * Implements hook_form_alter
 */
function openruth_form_ding_cart_list_form_alter(&$form, &$form_state) {
  $interest_period = (isset($account->interest_period) && $account->interest_period > 10) ? $account->interest_period : DING_LIBRARY_USER_DEFAULT_INTEREST_PERIOD;

  $form['options']['expiry'] = array(
    '#type' => 'date_popup',
    '#title' => t('Not interested after'),
    '#date_format' => DATE_FORMAT_DATE,
    '#date_year_range' => '-0:+2',
    '#default_value' => date('Y-m-d', $_SERVER['REQUEST_TIME'] + $interest_period * 86400),
  );

  $form['options']['pickup_branch'] = array(
    '#type' => 'select',
    '#title' => t('Pickup branch'),
    '#options' => _openruth_get_agency_counters(),
  );

  $form['reserve'] = array(
    '#type' => 'submit',
    '#value' => t('Reserve selected'),
    '#attributes' => array('class' => 'reserve-button'),
    '#op' => 'reserve',
    '#submit' => array('openruth_ding_cart_list_form_submit'),
  );
}

/**
 * Custom submit handler
 */
function openruth_form_ding_cart_list_form_submit($form, &$form_state) {
  foreach ($form_state['values']['selected'] as $local_id) {
    $reservation = ding_provider_invoke('reservation', 'create', $form_state['values']['account'], $local_id, array('expiry' => $form_state['values']['expiry'], 'pickup_branch' => $form_state['values']['pickup_branch']));

    // If reservation was successful, remove the item from the cart.
    if ($reservation and $reservation != DING_PROVIDER_AUTH_REQUIRED) {
      db_query("DELETE FROM {ding_cart} WHERE uid = %d AND local_id = '%s';", $form_state['values']['account']->uid, $local_id);
    }
    else {
      drupal_set_message(t('Reservation of “@title” failed. It may be on your reservation list already.', array('@title' => $form['cart']['#value'][$local_id]['title'])), 'error');
    }
  }
}

// Booking related functions.

/**
 * Return booking error message if it's a user error.
 */
function openruth_booking_user_error($error) {
  static $errors;
  if (!$errors) {
    $errors = array(
      "overbooking" => t('Overbooking'),
      "normal period of booking exceeded" => t('Normal period of booking exceeded'),
      "number of fetched copies exceeds number of ordered copies" => t('Number of fetched copies exceeds number of ordered copies'),
      // Marginal.
      "booking can not be deleted" => t('Booking can not be deleted'),
    );
  }

  if (isset($errors[$error])) {
    return $errors[$error];
  }
  return NULL;
}

function openruth_form_ding_booking_list_form_alter(&$form, $form_state) {
  $form['buttons']['remove'] = array(
    '#type' => 'submit',
    '#value' => t('Delete selected bookings'),
    '#attributes' => array('class' => 'cancel-button'),
    '#submit' => array('openruth_ding_booking_list_form_remove'),
  );
}
/**
 * Submit function.
 *
 * Updates selected bookings.
 */
function openruth_ding_booking_list_form_remove($form, $form_state) {
  ding_library_user_required();

  $bookings_ids = array_filter($form_state['values']['selected']);

  $successes = $failures = array();
  foreach ($bookings_ids as $bookings_id) {
    if (openruth_client()->cancel_booking($bookings_id)) {
      $successes[] = $bookings_id;
    }
    else {
      $failures[] = $bookings_id;
    }
  }

  if (!empty($successes) && empty($failures)){
    drupal_set_message(t('Bookings deleted.'));
  }

  elseif (!empty($failures) && empty($successes)) {
    drupal_set_message(t('Could not delete bookings.'), 'error');
  }
  else {
    drupal_set_message(t('Deleted @ok_count bookings, @failed_count failed', array('@ok_count' => sizeof($successes), '@failed_count' => sizeof($failures))), 'error');
  }
  // Flush cached user status.
  _openruth_user_status();
}
