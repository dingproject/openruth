<?php
// $Id$

/**
 * @file openruth.module
 * Drupal implementation of ZRuth's openruth SOAP API
 */

/**
 * Return an OpenruthClient instance.
 */
function openruth_client() {
  // This is basically a singleton. We also wait until right before
  // instantiating to include our required classes. That seems like a
  // decent performance tradeoff instead of loading everything on every
  // page load.
  static $client;
  if (!isset($client)) {
    $path = drupal_get_path('module', 'openruth');
    include($path . '/lib/OpenruthClient/OpenruthClient.class.php');
    $client = new OpenruthClient(
      variable_get('openruth_wsdl_url', ''),
      variable_get('openruth_agency_id', '')
    );
  }
  return $client;

}

// USER FUNCTIONS


/**
 * Implementation of hook_user().
 */
function openruth_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'login':
      if ($account->openruth_creds) {
        $_SESSION['openruth_creds'][$account->uid] = $account->openruth_creds;
        unset($account->openruth_creds);
      }
      break;
  }
}

/**
 * Implementation of hook_cron().
 *
 * Delete credentials after a while.
 */
function openruth_cron() {
  $expire_time = $_SERVER['REQUEST_TIME'] - variable_get('openruth_credential_cache_duration', 1800);
  $res = db_query("SELECT sid, session, timestamp FROM {session} WHERE timestamp < %d", $expire_time);
  // As the only PHP functions that reads and writes the
  // almost-but-not-quite-serialized-data format of sessions does it to/from
  // the current session, we're using our own session as a scratchpad.
  $old_session = $_SESSION;
  while ($row = db_fetch_object($res)) {
    $_SESSION = array();
    session_decode($ros->session);
    if (isset($_SESSION['openruth_creds'])) {
      unset($_SESSION['openruth_creds']);
      $new_session = session_encode();
      db_query("UPDATE {session} SET session = '%s' WHERE sid = %d AND timestamp = %d", $new_session, $row->sid, $row->timestamp);
    }
  }
  $_SESSION = $old_session;
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function openruth_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ding_provider') {
    return "plugins/$plugin";
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * Alter the login form to disable the standard Drupal username/password
 * combination and provide our own fields instead.
 */
function openruth_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    case 'user_login':
    case 'user_login_block':
      // Since the login name can be a user's CPR-number, that too is hidden.
      $form['name']['#type'] = 'password';
      // Add our own validation handler, before the default Drupal login
      // validator.
      array_splice($form['#validate'], array_search('user_login_authenticate_validate', $form['#validate']), 0, 'openruth_user_login_validate');
      break;
  }
}

/**
 * Validation for the login form.
 */
function openruth_user_login_validate($form, &$form_state) {
  openruth_authenticate($form_state['values']);
}

/**
 */
function openruth_authenticate(&$form_values) {
  $res = openruth_client()->user_check($form_values['name'], $form_values['pass']);

  if (is_string($res)) {
    watchdog('openruth', 'Error in user_check: @error', array('@error' => $res), WATCHDOG_ERROR);
    return;
  }
  elseif (!$res->userFound || !$res->userPinCodeOk) {
    // Not found.
    return;
  }

  if ($res->userBlocked) {
    // Tell the user...
  }

  $auth_name = md5(drupal_get_private_key() . $form_values['name']) . '@openruth';
  user_external_login_register($auth_name, 'openruth_user');

  global $user;
  // Save credentials for later use.
  $user->openruth_creds = array(
    'user_id' => $form_values['name'],
    'password' => $form_values['pass'],
  );

  $user_status = _openruth_user_status($user, $form_values['name'], $form_values['pass']);

  if ($user_status && isset($user_status->userInfo)) {
    $user_info = $user_status->userInfo;
    // Set display_name
    $user->display_name = $user_info->userFirstName . ' ' . $user_info->userLastName;
  }
  elseif ($res->userEmail) {
    $user->display_name = $res->userEmail;
  }
  else {
    // What can we do? Use auth_name.
    $user->display_name = $auth_name;
  }

  // Finalize login.
  user_authenticate_finalize($form_values);
}

/**
 * Get OpenRuth credentials for user.
 */
function _openruth_get_credentials($account) {
  // See if we have credentials for the given user in the session.
  if ($_SESSION['openruth_creds'][$account->uid]) {
    return $_SESSION['openruth_creds'][$account->uid];
  }
  return DING_PROVIDER_AUTH_REQUIRED;
}

/**
 * Get user status.
 *
 * Session cached for efficiency.
 */
function _openruth_user_status($account = NULL, $name = NULL, $pass = NULL) {
  // Flush cache if account is not specified.
  if (!is_array($_SESSION['openruth_user_status']) || !$account) {
    $_SESSION['openruth_user_status'] = array();
  }
  if (!$account) {
    return;
  }

  if (!$name) {
    $creds = _openruth_get_credentials($account);
    if ($creds == DING_PROVIDER_AUTH_REQUIRED) {
      return;
    }
    $name = $creds['user_id'];
    $pass = $creds['password'];
  }
  $id = md5($name . $pass);

  if (!isset($_SESSION['openruth_user_status'][$id]) ||
    $_SESSION['openruth_user_status'][$id]['time'] < ($_SERVER['REQUEST_TIME'] - 300)) {
    $status = openruth_client()->user_status($name, $pass);
    if ($status && !is_string($status)) {
      $_SESSION['openruth_user_status'][$id] = array(
        'time' => $_SERVER['REQUEST_TIME'],
        'data' => $status,
      );
    }
    elseif (is_string($status)) {
      watchdog('openruth', 'Error fetching user status @error', array('@error' => $status), WATCHDOG_ERROR);
      return;
    }
  }
  if ($_SESSION['openruth_user_status'][$id]) {
    return $_SESSION['openruth_user_status'][$id]['data'];
  }
}

/**
 * Map openruth error messages to user visible error messages.
 *
 * @param mixed $error
 *   An specific error message, if empty, return array of all messages.
 * @return mixed
 *   String or array, depending on arguments.
 */
function openruth_renew_error($error = NULL) {
  static $errors;
  if (!$errors) {
    $errors = array(
      "rejected" => t('Renewal rejected.'),
      "reserved" => t('Cannot renew, material reserved,'),
      "booked" => t('Cannot renew, material reserved'),
      "copy reserved" => t('Cannot renew, material reserved'),
      "user is blocked" => t('Renewal rejected.'),
      "copy not on loan by user" => t('Renewal rejected.'),
      "copy not on loan" => t('Renewal rejected.'),
      "copy does not exist" => t('Renewal rejected.'),
      "ILL, not renewable" => t("Renewal not possible"),
      // Special case
      'not implemented yet' => t("Not implemented"),
    );
  }

  if ($error) {
    if (isset($errors[$error])) {
      return $errors[$error];
    }
    return $errors['rejected'];
  }
  return $errors;
}

// Reservation related functions.

function openruth_form_ding_reservation_list_form_alter(&$form, $form_state) {
  $form['options']['new_expiry'] = array(
    '#type' => 'date_popup',
    '#title' => t('Valid to'),
    '#date_format' => DATE_FORMAT_DATE,
    '#date_year_range' => '-0:+2',
  );

  $form['options']['new_pickup_branch'] = array(
    '#type' => 'select',
    '#title' => t('New pickup branch'),
    '#options' => openruth_client()->get_agency_counters(),
  );

  $form['buttons']['update'] = array(
    '#type' => 'submit',
    '#value' => t('Save changes for selected reservations'),
    '#attributes' => array('class' => 'update-button'),
    '#validate' => array('openruth_ding_reservation_list_form_validate'),
    '#submit' => array('openruth_ding_reservation_list_form_update'),
  );

  $form['buttons']['remove'] = array(
    '#type' => 'submit',
    '#value' => t('Delete selected reservations'),
    '#attributes' => array('class' => 'cancel-button'),
    '#submit' => array('openruth_ding_reservation_list_form_remove'),
  );

}

function openruth_ding_reservation_list_form_validate($form, $form_state) {
  $reservations = $form_state['values']['reservations'];
  foreach (array_filter($form_state['values']['selected']) as $id) {
    // Detect fetable reservations...
    if (($reservations[$id]['status'] == 'fetchable')) {
      if (!empty($form_state['values']['new_expiry'])) {
        form_error($form['selected'][$id], t('You can not change expiry on reservations which are ready for pick up'));
      }
      if ($form_state['values']['new_pickup_branch'] != $reservations[$id]['pickup_branch']) {
        form_error($form['selected'][$id], t('You can not change pickup branch on reservations which are ready for pick up'));
      }
    }
  }

  if (!empty($form_state['values']['new_expiry'])) {
    list($year, $month, $day) = explode('-', trim($form_state['values']['new_expiry']));
    if (!checkdate($month, $day, $year)) {
      form_error($form['options']['new_expiry'], t('Invalid date'));
    }

    $timestamp = strtotime($form_state['values']['new_expiry']);

    if ($timestamp <= $_SERVER['REQUEST_TIME']) {
      form_error($form['options']['new_expiry'], t('Date must be later than today.'));
    }
    else {
      form_set_value($form['options']['new_expiry'], format_date($timestamp, 'custom', 'Y-m-d'), $form_state);
    }
  }
}

/**
 * Submit function.
 *
 * Updates selected reservations.
 */
function openruth_ding_reservation_list_form_update($form, $form_state) {
  // TODO: Not implemented in the service yet.
  $creds = _openruth_get_credentials($form_state['values']['account']);
  if ($creds == DING_PROVIDER_AUTH_REQUIRED) {
    drupal_set_message('You must be logged in to delete reservations');
    return;
  }
  $reservations_ids = array_filter($form_state['values']['selected']);
  $changes = array();
  if ($form_state['values']['new_expiry']) {
    $changes['expiry'] = $form_state['values']['new_expiry'];
  }
  if ($form_state['values']['new_pickup_branch']) {
    $changes['pickup_branch'] = $form_state['values']['new_pickup_branch'];
  }
  $res = TRUE;
  foreach ($reservations_ids as $reservations_id) {
    // alma_client_change_reservation($creds['user_id'], $creds['password'], $form_state['reservations'][$reservations_id], $changes);
  }
  drupal_set_message(t('Reservations updated.'));
}

/**
 * Submit function.
 *
 * Updates selected reservations.
 */
function openruth_ding_reservation_list_form_remove($form, $form_state) {
  // TODO: Not implemented in the service yet.
  $creds = _openruth_get_credentials($form_state['values']['account']);
  if ($creds == DING_PROVIDER_AUTH_REQUIRED) {
    drupal_set_message('You must be logged in to delete reservations');
    return;
  }
  $reservations_ids = array_filter($form_state['values']['selected']);
  $res = array();
  foreach ($reservations_ids as $reservations_id) {
    $res[] = openruth_client()->cancel_order($reservations_id);
  }
  $counts = array_count_values($res);
  if (isset($counts[TRUE]) && !isset($counts[FALSE])){
    drupal_set_message(t('Reservations deleted.'));
  }
  elseif (isset($counts[FALSE]) && !isset($counts[TRUE])) {
    drupal_set_message(t('Could not delete reservations.', 'error'));
  }
  else {
    drupal_set_message(t('Deleted @ok_count reservations, @failed_count failed', array('@ok_count' => $counts[TRUE], '@failed_count' => $counts[FALSE])), 'error');
  }
}

// Cart reservation support.

/**
 * Implements hook_form_alter
 */
function openruth_form_ding_cart_list_form_alter(&$form, &$form_state) {
  $interest_period = (isset($account->interest_period) && $account->interest_period > 10) ? $account->interest_period : DING_LIBRARY_USER_DEFAULT_INTEREST_PERIOD;

  $form['options']['expiry'] = array(
    '#type' => 'date_popup',
    '#title' => t('Not interested after'),
    '#date_format' => DATE_FORMAT_DATE,
    '#date_year_range' => '-0:+2',
    '#default_value' => date('Y-m-d', $_SERVER['REQUEST_TIME'] + $interest_period * 86400),
  );

  $form['options']['pickup_branch'] = array(
    '#type' => 'select',
    '#title' => t('Pickup branch'),
    '#options' => openruth_client()->get_agency_counters(),
  );

  $form['reserve'] = array(
    '#type' => 'submit',
    '#value' => t('Reserve selected'),
    '#attributes' => array('class' => 'reserve-button'),
    '#op' => 'reserve',
    '#submit' => array('openruth_ding_cart_list_form_submit'),
  );
}

/**
 * Custom submit handler
 */
function openruth_form_ding_cart_list_form_submit($form, &$form_state) {
  foreach ($form_state['values']['selected'] as $local_id) {
    $reservation = ding_provider_invoke('reservation', 'create', $form_state['values']['account'], $local_id, array('valid_to' => $form_state['values']['expiry'], 'pickup_branch' => $form_state['values']['pickup_branch']));

    // If reservation was successful, remove the item from the cart.
    if ($reservation and $reservation != DING_PROVIDER_AUTH_REQUIRED) {
      db_query("DELETE FROM {ding_cart} WHERE uid = %d AND local_id = '%s';", $form_state['values']['account']->uid, $local_id);
    }
    else {
      drupal_set_message(t('Reservation of “@title” failed. It may be on your reservation list already.', array('@title' => $form['cart']['#value'][$local_id]['title'])), 'error');
    }
  }
}
